### HashFun
2. ##### 不同哈希策略的实现
   - 坏哈希: $\sum_ (str[i] * str[i]) \bmod N$
   - 好哈希: $\sum_ (str[i] * 151 ^ {n-i-1}) \bmod N$
   - 双向平方试探策略
      - 增加一个index记录信息，index初始化为0
      - 每次进入的时候，如果为正，说明这次需要负向探测，反之，index的绝对值变大1，正向探测(0需要特判)
         > return (last +(-) x * x) % s;
   - 公共溢出区策略
      - 原大小一半作为缓冲区
      - index初始化为
      - 每次返回缓冲区的下一个元素(缓冲区是从原始table_size/2开始的)
         > x++;
         > x %= s;
         > return x + s;
3. ##### 测试数据
   - 构造方法，先全部读取进来，然后用srand()函数根据当前时间进行初始化，每次选取数据的时候，随机产生一个x和y，表示要访问的数组的下标，y表示使用每行3个整数的哪一个
   - 然后产生的3个输入文件分别是按照插入的大小和我的哈希表的比例构造的，分别是30%,50%,70%
4. ##### 分析结果
   1. 好的哈希函数性能好，因为坏的哈希函数哈希值相同的情况多，冲突多
   2. 双向平方探测性能远高于线性探测，数据随机生成，很容易出现聚集现象
   3. 封闭散列占优势，开放散列在均匀分布的数据并且对访问性能要求高的时候更适合
   4. 哈希冲突增加
   5. 维护一个负载因子，超过某个阈值就触发扩容操作，创建一个更大的哈希表，然后将旧哈希的元素重新插入到新的哈希表中，释放旧哈希表占用的内存空间，缩容同理
5. ##### 改动
   1. 在insert和query加上如果是缓冲区策略，修改table_size
   2. hashtable增加两个接口，用于修改my_hashing和my_collision
6. ##### 感受和建议
   - 第一部分字数不可以超过400字，不知道包不包括代码的长度，插入代码很难压缩到400字
   - 构造数据的时候不是很清楚应该构造怎样的数据


