### Filename

- **算法实现思路**
    
    - 一开是用一个二维数组进行动态规划求出两个字符串的最大公共字串长度，但是复杂度是O(n * m)，会超时，想不到怎么优化，想能不能不计算某些数据，但是发现好像不行，因为想要知道最大公共子串的长度，就必须要要对二维数组的每一个元素进行计算。
    
    - 后面看了网络学堂发的题解之后明白了，并不需要知道两个的最大公共子串长度，只需要知道在他们能否在k次修改之内变相等，所以有些信息就是不需要的，如下图所示
    
      ```shell
      10 11 5
      9873007613
      87300676513
      0 0 0 0 0 0
      1 1 1 1 1 1 1
      1 2 2 2 2 2 2 2
      1 2 3 3 3 3 3 3 3
      1 2 3 4 4 4 4 4 4 4
      1 2 3 4 5 5 5 5 5 5 5
        2 3 4 5 5 6 6 6 6 6
          3 4 5 6 6 7 7 7 7
            4 5 6 6 7 7 8 8
              5 6 6 7 7 8 9
      ans: 3
      ```
    
      上面每行最多只计算了1 + 2 * 5 = 11个数据，也就是每个横纵坐标相等元素的前k位和后k位，因为其他的对结果是不会有贡献的，或者说从其他位置到达终点，那需要修改的次数必然大于k，这样复杂度就会降到O(k * n)，实现和之前的也是一样的，只是第二个循环的条件发生变化。
    
- **遇到的问题：**
  
- 前面说的，不知道怎么降低复杂度，但是看了题解之后就懂了
  
- **时间复杂度：O(k * n)**

    - n次循环，每次计算2k+1个值
    `O(n * (2 * k + 1)) = O(k * n)`
    
- **空间复杂度：O(k)**

    - n次计算，每次最多2k+1个，但是前面的数据只会使用一次，故可以使用滚动数组降低空间复杂度
    `O(2k + 1) = O(k)`