#### Graphics
- **算法实现的思路：**
    - 因为所有的直线不会相交，所以可以确定两组点的排序方式都是从小到大，这可以用快速排序实现，得到所有的直线序列后，问直线OP和会和多少个直线产生交点，其实就是点P在多少个直线的右上方，可以将点P的坐标带入直线公式，得到的值与0进行比较即可判断是否在右上方，但显然不需要逐个比较，如果P在第x个直线的右上方，那么也必然在前面的x-1条直线上方，如果在第y条直线的下方，那么也肯定在后面n-y条直线的下面，所以我们只需要找到那个临界直线就好了，虽然计算得出的值不是单调的，但是前面的计算出的值都会小于0，而后面会大于0，所以根据这个就可以写一个二分搜索，每次判断中间数对应的直线与点P计算得到的值，如果大于等于0，那就说明答案肯定在后半段，小于0就在前半段。
- **遇到的问题：**
    - 数据溢出：因为在将点的坐标带入直线方程的时候，会有乘法，而题中给的数据在极端情况下得到的结果就会超出int的范围，解决自然就是使用long long
- **时间复杂度：O(max(n, m) * log(n))**
    - 两次快速排序加m次二分搜索
    `2 * O(nlog(n)) + O(mlog(n)) = O(max(n, m) * log(n))`
- **空间复杂度：O(n)**
    - 两个数组存储点的坐标，5个变量(直线和点的个数，每次点的坐标，答案)
    `2 * O(n) + O(5) = O(n)`