### Polynomial

- ##### 算法实现的思路
    - 这个和课堂上讲的唯一区别就是操作数不同，这个里面操作数比较特殊，不像89，76这种可以直接使用数组存储，这个会遇到$x，8x^4+4x^3+1$这种多项式，所以需要先使用一个结构体去表示这个多项式，因为限定了多项式的最高次数，所以我直接只用一个数组去存储多项式每一项前面的系数，在加上一个辅助位，表示最大的次数，这样可以减少一些计算。然后就是重载运算符
    ```c++
    struct Num {
        int nums[65];
        int h;

        Num& operator+=(const Num& other);
        Num& operator-=(const Num& other);
        Num& operator*=(const Num& other);
        Num& operator^=(int k);
    }
    ```
    - 接下来使用两个数组存储运算符号和多项式，并手动维护两个指针去模拟栈的行为
    ```c++
    char* operators = new char[n + 1];
    Num* values = new Num[n / 2 + 2];//因为最坏的情况下也只会有(n+1)/2个操作数
    int opint = 0;
    int vpoint = 0;
    ```
    - 接下来循环处理字符串就好了，首先就是检查省略的乘号，这个我是想着，先用一个last存储上一个出现的字符，然后结合这一次出现的字符就可以进行判断，接着就是处理各种符号，遇到'('，')'和'\^'单独处理，然后比较优先级的时候，定义一个可以返回优先级的函数就可以，比如乘号返回2，加和减返回1，括号就返回0，(因为'\^'已单独处理，所以不会出现)，最主要的还是处理遇到的单项式，下面详细说明
    ```c++
            int nums[65] = { 0 };
            int h = 0;
            //单项式分为有系数的和无系数的
            if (c == 'x') {
                last = c;
                h = 1;
                while (i < n - 1 && expression[i + 1] == '^') {
                    i += 2;
                    h *= expression[i] - '0';
                    last = '0';
                }//处理x^4^4^4这种情形
                nums[h] = 1;
            } else {
                last = '0';
                long long int tmp = c - '0';//不开long long会爆
                while (i < n - 1 && isdigit(expression[i + 1])) {
                    i++;
                    tmp = 10 * tmp + (long long int)(expression[i] - '0');
                    if (tmp >= M)//比M大就取模
                        tmp %= M;
                }//得到系数
                if (i < n - 1 && expression[i + 1] == 'x') {//次数大于等于1的情况，和上面处理无系数的是一样的
                    last = 'x';
                    i++;
                    h = 1;
                    while (i < n - 1 && expression[i + 1] == '^') {
                        i += 2;
                        h *= expression[i] - '0';
                        last = '0';
                    }
                    nums[h] = tmp;
                } else {//次数为1的情况
                    nums[0] = tmp;
                    h = 0;
                }
            }
            values[vpoint] = Num(nums, h);
            vpoint++;//更新操作数数量
    ```

- ##### 遇到的问题
    - 数据取模问题
        - 忽略了系数可能超出int的情况
    - 省略的乘号问题
        - 我考虑的时候觉得对于x只有前面是')'的时候才有可能有省略的乘号(我认为数字后面紧跟x就一定是单项式)，忽略了$x^2x$这种依然是省略了乘号的，

- ##### 时间复杂度: $o(500n)$
    - 加法和减法: $O(h)$ h为多项式次数
    - 乘法: $O(h_1*h_2)$ 
    - 幂运算: $O(h^k)$
    - 上面幂运算的最坏情况为$h=16,k=4,$ 会进行$O(1536)$次运算，由于涉及两个字符，所以均摊到每个字符上就是$O(768)$，乘法至少两个，所以为$O(512)$，但是乘法操作次数多，加法只有$O(32)$，所以即使是最坏的情况，也一定会小于$1000n$，其实应该比$1000n$小的多，但是不知道怎么准确地去说明这一点，因为幂运算和乘法的最坏情况都是需要基础的，即操作数的要有对应的次数，而这个次数的构造过程平均操作次数必然比768或者512小很多，所以再平均，必然会进一步减小。至少会比$500n$小

- ##### 空间复杂度: $O(n)$
    - 运算符数组: $O(n)$
    - 操作数数组: $O(n)$      
        - $(n/2)*66 = 33n$