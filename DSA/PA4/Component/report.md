# Component
### 1. 算法实现的思路
- 用并查集为每个元素维护连通块信息，包含查找和合并操作，查找的时候可以优化一下，可以更新一下父节点，这样之后再次访问的时候，就无需遍历那么多次，直接就可以找到
    - `unionFind(int x)`
    ```c++
        if (fa[x] == x)
            return x;
        else {
            fa[x] = unionFind(fa[x]);
            return fa[x];
        }
    ```
    - `unionMerge(int x, int y)`
    ```c++
    fa[y] = x;
    ```
- 用左式堆维护每个连通块的一个最小堆，并且**只维护k个**，这样k查询**直接返回堆顶元素**就好了
    - `merge`
    先取小堆作为根，然后合并其右儿子和另一个堆，合并完之后检查左右儿子是否需要交换，然后更新size和零距离信息，若$size > k$，就从根节点开始**删除(合并左右儿子)**，直至等于k
- 初始化，并查集中每个元素的父亲都是自己，把每个元素看成一个连通块，在自己的左式堆加上对点的点信息，这样，由于不会有一个点会出现在两个连通块中的情况，之后只需要考虑合并，无需插入
    ```c++
    for (int i = 0; i < n; i++) {
        scanf("%d", &nodes[i]);
        heaps[i] = new Node(nodes[i]);;
        fa[i] = i;
    }
    ```
- 加边操作，先依据并查集得出两个是否属于同一个连通块，如果是，无需操作，它们的信息肯定被左式堆使用了的，如果不是，就合并两个对应的并查集和左式堆
    ```c++
    void addEdge(int a, int b) {
        int u1 = unionFind(a - 1);
        int u2 = unionFind(b - 1);
        if (u1 != u2) {
            unionMerge(u1, u2);
            heaps[u1] = merge(heaps[u1], heaps[u2]);
        }
    }
    ```
- 第k大元素查询，若小于k，返回-1，否则直接返回堆顶元素
    ```c++
    int kthFind(Node* root) {
        if (root->size < k)
            return -1;
        return root->val;
    }
    ```
### 2. 遇到的问题
- 并查集和左式堆(最大堆)可以想清楚，但是不知道如何在左式堆中快速找到第k大元素值，后来考虑到k是固定的，所以有些信息就是冗余的，只需转而存为一个最小堆，并且最多k个元素，这样查找相当简单
### 3. 时间复杂度: $O((m+q)(α(n)+logk))$
- 并查集查找: **$O((m+q)α(n))$**
- 并查集合并: **$O(m+q)$**
- 左式堆合并: **$O((m+q)logk)$**
- k查询: **$O(q)$**
### 4. 空间复杂度: $O(n + logn)$
- 数组大小: $O(n)$
- 函数递归调用: $O(logn)$
### 5. 参考
- 并查集查找路径压缩优化https://oi-wiki.org/ds/dsu/
- 并查集查找时间复杂度https://oi-wiki.org/ds/dsu/