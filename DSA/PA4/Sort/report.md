# Sort
### 1. 算法实现的思路
- 感觉归并排序比较好扩展，于是问题就是如何选取归并的路数以比较的次数最少，而比较次数由两个因素决定，一是每次归并时比较次数和各路数组总长度的关系，二是需要归并的次数，即归并时递归的深度
- 先看3路归并，如果归并的三个数组的长度总和为x，最坏的情况下比较次数是x，递归深度是$log_3n$，所以最后比较的次数就是$nlog_3n$，可以发现规律，最后的比较次数就是在归并时为了选出最小者而需要进行比较的平均次数k，乘以$nlog_an$(a是归并路数)，得到的比较次数就是$knlog_an$，由测试点20的信息，可以得到$klog_a10 <= 10.3/6$，3路归并无法满足，4路归并若$k=1$即可满足，下面给出四路时$k=1$的比较方法
- 有四个数组$A,B,C,D$，预处理(4个均不为空)，比较前三个数组(数组的当前元素)，并根据结果交换次序，并交换$C^{'}和D$。然后开始循环，如果数组个数大于3，每次先比较前三个数组，如果有4个，就交换3和4，这样做的原因是，3不可能是最小的了，但是4有可能成为最小的，所以把它交换到比较的序列中，然乎把第一个数组的元素弹出来，并判断是否为空，如果空了就把第n个数组放到第一个数组(n是当前数组个数)，数组个数减1，如果只有两个，就变成了普通的二路归并。这样的话，除了预处理的一次比较，后续比较都是1次就可以找出最小值,下面是核心代码
    ```c++
    if (n == 4)// n是数组个数
        com(n, a);
    while (n > 2) {
        com(n, a);
        a[start] = arr[num[order[0]]];
        start++;
        num[order[0]]++;
        if (num[order[0]] == end[order[0]]) {//数组空了
            n--;
            order[0] = order[n];
        }
    }
    ```
- 5路和6路没有详细分析，但是从表达式上可以看出，k对结果大小的影响是要大于a的，而5路和6路的k感觉不能等于1，那结果自然是无法满足的
### 2. 遇到的问题
- 三个元素全部相同的时候最小值和最大值是同一个值，所以需要特殊处理一下，忽略这个
### 3. 时间复杂度: $O(nlogn)$
### 4. 空间复杂度: $O(n)$
- 直接开一个静态数组，每次将需要归并的四个数组全部复制过去，这样代码比较好写