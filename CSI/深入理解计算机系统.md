### 深入理解计算机系统

#### 第三章 程序的机器级表示

- 学习目标：

  1. c语言，汇编代码以及机器代码之间的关系

  2. 数据处理和控制实现

  3. 过程实现

  4. 数据结构

  5. 内存访问越界

  6. GDB调试

- 3.1 历史观点
  
- 摩尔定律：芯片上晶体管数量的增长规律
  
- 3.2 程序代码

  - 隐藏的处理器

    |      处理器名称      |                 作用                 |
    | :------------------: | :----------------------------------: |
    | 程序计数器（**PC**） |     存储下一条指令在内存中的地址     |
    |      整数寄存器      |          存储地址或整数数据          |
    |     条件码寄存器     | 最近执行的算术或者逻辑指令的状态信息 |
    |      向量寄存器      |    存放一个或多个整数或者浮点数值    |

  - 机器代码特性

    - x86-64指令长度从1到15个字节不等。常用的指令字节数少
    - 反汇编器只是基于机器文件中的字节序列
    - 'q'后缀可省略
    
  - 程序使用汇编代码的方法

    - 使用汇编语言编写函数，链接的时候链接到一起
    - 使用内联汇编特性

- 3.3 数据格式

  - **TODO**：列出类型对应的字节和后缀表

- 3.4 访问信息

  - **TODO**：
    - 1. 寄存器表
      2. 操作数类型
      3. 数据传送（后缀匹配，传送示例 and movabsq）
      4. 扩展

- 3.5 算术和逻辑操作

  - **TODO**：
    - 1. 移位
      2. 特殊的算术操作
  
- 3.6 控制

  - 条件码
  - 整数和浮点数具有不同的指令和硬件
  - 跳转（goto风格，直接和间接跳转，相对和绝对跳转编码）
  - 全局变量的访问依赖rip寄存器，且偏移量动态变化
  - 条件控制和条件传送
    - 前者改变程序的控制流，会发生预测错误
    - 后者不改变控制流，只是根据条件决定是否执行某个操作，更有效率，但是只有在满足限定条件的情况下才可以使用，比如分支里面有副作用就不可以
      - 计算分支预测处罚时间：***T***<sub>ran</sub> = ***T***<sub>OK</sub> + 0.5***T***<sub>MP</sub>
      - 性能不一定总是好，因为会浪费计算资源

