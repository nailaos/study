### 深入理解计算机系统

#### 第三章 程序的机器级表示

- 学习目标：

  1. c语言，汇编代码以及机器代码之间的关系

  2. 数据处理和控制实现

  3. 过程实现

  4. 数据结构

  5. 内存访问越界

  6. GDB调试

- 3.1 历史观点
- 摩尔定律：芯片上晶体管数量的增长规律
- 3.2 程序代码

  - 隐藏的处理器

    |      处理器名称      |                 作用                 |
    | :------------------: | :----------------------------------: |
    | 程序计数器（**PC**） |     存储下一条指令在内存中的地址     |
    |      整数寄存器      |          存储地址或整数数据          |
    |     条件码寄存器     | 最近执行的算术或者逻辑指令的状态信息 |
    |      向量寄存器      |    存放一个或多个整数或者浮点数值    |

  - 机器代码特性

    - x86-64指令长度从1到15个字节不等。常用的指令字节数少
    - 反汇编器只是基于机器文件中的字节序列
    - 'q'后缀可省略

  - 程序使用汇编代码的方法

    - 使用汇编语言编写函数，链接的时候链接到一起
    - 使用内联汇编特性

- 3.3 数据格式

  - **TODO**：列出类型对应的字节和后缀表

- 3.4 访问信息

  - **TODO**：
    - 1. 寄存器表
      2. 操作数类型
      3. 数据传送（后缀匹配，传送示例 and movabsq）
      4. 扩展

- 3.5 算术和逻辑操作

  - **TODO**：
    - 1. 移位
      2. 特殊的算术操作

- 3.6 控制

  - 条件码
  - 整数和浮点数具有不同的指令和硬件
  - 跳转（goto风格，直接和间接跳转，相对和绝对跳转编码）
  - 全局变量的访问依赖rip寄存器，且偏移量动态变化
  - 条件控制和条件传送
    - 前者改变程序的控制流，会发生预测错误
    - 后者不改变控制流，只是根据条件决定是否执行某个操作，更有效率，但是只有在满足限定条件的情况下才可以使用，比如分支里面有副作用就不可以
      - 计算分支预测处罚时间：**_T_**<sub>ran</sub> = **_T_**<sub>OK</sub> + 0.5 **_T_**<sub>MP</sub>
      - 性能不一定总是好，因为会浪费计算资源
  - 循环
    - do-while比较基础，while和for是等价的，两种转换方式：jump to middle，guarded-do
  - switch语句
    - 情况数量较多，值的范围跨度比较小，就会使用跳转表

- 3.7 过程
  - 转移控制和数据传送
    - PC，%rsp，(%rsp)的变化
    - 参数大于6个时，通过栈去传递
  - 栈上和寄存器上的存储
    - 栈帧
    - 返回地址指的就是返回调用者的进程后应该执行的语句所在的位置，返回地址之前存的就是额外的参数，这样被调用者就可以先读取参数进行计算，然后可以继续使用栈，而不用担心因为栈指针的变化，而不知道偏移量无法访问额外参数的问题
    - 寄存器使用惯例
  - 递归过程(和一般函数调用并无较大区别)
- 3.8 数组分配和访问
  - 基本原则
  - 指针运算
    - 两个指针之差等于地址之差除以该数据类型的大小
      `&E[i] - E = i`
  - 嵌套数组
    - 索引变为伸缩的偏移量即可
